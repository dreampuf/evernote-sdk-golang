// Autogenerated by Thrift Compiler (0.9.3)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package userstore

import (
	"bytes"
	"fmt"
	"github.com/apache/thrift/lib/go/thrift"
	"github.com/dreampuf/evernote-sdk-golang/errors"
	"github.com/dreampuf/evernote-sdk-golang/types"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var _ = types.GoUnusedProtection__
var _ = errors.GoUnusedProtection__

type UserStore interface { //Service:  UserStore
	//<p>
	//The UserStore service is primarily used by EDAM clients to establish
	//authentication via username and password over a trusted connection (e.g.
	//SSL).  A client's first call to this interface should be checkVersion() to
	//ensure that the client's software is up to date.
	//</p>
	//All calls which require an authenticationToken may throw an
	//EDAMUserException for the following reasons:
	// <ul>
	//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
	//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
	//  <li> DATA_REQUIRED "authenticationToken" - token is empty
	//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
	//  <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
	//    privileges
	//</ul>

	// This should be the first call made by a client to the EDAM service.  It
	// tells the service what protocol version is used by the client.  The
	// service will then return true if the client is capable of talking to
	// the service, and false if the client's protocol version is incompatible
	// with the service, so the client must upgrade.  If a client receives a
	// false value, it should report the incompatibility to the user and not
	// continue with any more EDAM requests (UserStore or NoteStore).
	//
	// @param clientName
	//   This string provides some information about the client for
	//   tracking/logging on the service.  It should provide information about
	//   the client's software and platform. The structure should be:
	//   application/version; platform/version; [ device/version ]
	//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
	//
	// @param edamVersionMajor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MAJOR
	//   constant for the client.
	//
	// @param edamVersionMinor
	//   This should be the major protocol version that was compiled by the
	//   client.  This should be the current value of the EDAM_VERSION_MINOR
	//   constant for the client.
	//
	// Parameters:
	//  - ClientName
	//  - EdamVersionMajor
	//  - EdamVersionMinor
	CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error)
	// This provides bootstrap information to the client. Various bootstrap
	// profiles and settings may be used by the client to configure itself.
	//
	// @param locale
	//   The client's current locale, expressed in language[_country]
	//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
	//   language and country codes.
	//
	// @return
	//   The bootstrap information suitable for this client.
	//
	// Parameters:
	//  - Locale
	GetBootstrapInfo(locale string) (r *BootstrapInfo, err error)
	// This is used to check a username and password in order to create a
	// long-lived authentication token that can be used for further actions.
	//
	// This function is not available to most third party applications,
	// which typically authenticate using OAuth as
	// described at
	// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
	// If you believe that your application requires permission to authenticate
	// using username and password instead of OAuth, please contact Evernote
	// developer support by visiting
	// <a href="http://dev.evernote.com">dev.evernote.com</a>.
	//
	// @param username
	//   The username or registered email address of the account to
	//   authenticate against.
	//
	// @param password
	//   The plaintext password to check against the account.  Since
	//   this is not protected by the EDAM protocol, this information must be
	//   provided over a protected transport (i.e. SSL).
	//
	// @param consumerKey
	//   The "consumer key" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param consumerSecret
	//   The "consumer secret" portion of the API key issued to the client application
	//   by Evernote.
	//
	// @param deviceIdentifier
	//   An optional string that uniquely identifies the device from which the
	//   authentication is being performed. This string allows the service to return the
	//   same authentication token when a given application requests authentication
	//   repeatedly from the same device. This may happen when the user logs out of an
	//   application and then logs back in, or when the application is uninstalled
	//   and later reinstalled. If no reliable device identifier can be created,
	//   this value should be omitted. If set, the device identifier must be between
	//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
	//   EDAM_DEVICE_ID_REGEX.
	//
	// @param deviceDescription
	//   A description of the device from which the authentication is being performed.
	//   This field is displayed to the user in a list of authorized applications to
	//   allow them to distinguish between multiple tokens issued to the same client
	//   application on different devices. For example, the Evernote iOS client on
	//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
	//   "Bob's iPad". The device description must be between 1 and
	//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
	//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
	//
	// @param supportsTwoFactor
	//   Whether the calling application supports two-factor authentication. If this
	//   parameter is false, this method will fail with the error code INVALID_AUTH and the
	//   parameter "password" when called for a user who has enabled two-factor
	//   authentication.
	//
	// @return
	//   <p>The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by
	//   calling application's API key.</p>
	//   <p>If the user has two-factor authentication enabled,
	//   AuthenticationResult.secondFactorRequired will be set and
	//   AuthenticationResult.authenticationToken will contain a short-lived token
	//   that may only be used to complete the two-factor authentication process by calling
	//   UserStore.completeTwoFactorAuthentication.</p>
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	//   <li> DATA_REQUIRED "password" - password is empty
	//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
	//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
	//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
	//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
	//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
	//   <li> INVALID_AUTH "username" - username not found
	//   <li> INVALID_AUTH "password" - password did not match
	//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
	//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	//   <li> AUTH_EXPIRED "password" - user password is expired
	// </ul>
	//
	// Parameters:
	//  - Username
	//  - Password
	//  - ConsumerKey
	//  - ConsumerSecret
	//  - DeviceIdentifier
	//  - DeviceDescription
	//  - SupportsTwoFactor
	AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult_, err error)
	// Complete the authentication process when a second factor is required. This
	// call is made after a successful call to authenticate or authenticateLongSession
	// when the authenticating user has enabled two-factor authentication.
	//
	// @param authenticationToken An authentication token returned by a previous
	//   call to UserStore.authenticate or UserStore.authenticateLongSession that
	//   could not be completed in a single call because a second factor was required.
	//
	// @param oneTimeCode The one time code entered by the user. This value is delivered
	//   out-of-band, typically via SMS or an authenticator application.
	//
	// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
	//
	// @param deviceDescription See the corresponding parameter in authenticateLongSession.
	//
	// @return
	//   The result of the authentication. The level of detail provided in the returned
	//   AuthenticationResult.User structure depends on the access level granted by the
	//   calling application's API key. If the initial authentication call was made to
	//   authenticateLongSession, the AuthenticationResult will contain a long-lived
	//   authentication token.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
	//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
	//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
	//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
	//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
	//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
	//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
	//   <li> PERMISSION_DENIED "User.active" - user account is closed
	//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
	//     failed authentication too often
	//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
	//      two-factor authentication.</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - OneTimeCode
	//  - DeviceIdentifier
	//  - DeviceDescription
	CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult_, err error)
	// Revoke an existing long lived authentication token. This can be used to
	// revoke OAuth tokens or tokens created by calling authenticateLongSession,
	// and allows a user to effectively log out of Evernote from the perspective
	// of the application that holds the token. The authentication token that is
	// passed is immediately revoked and may not be used to call any authenticated
	// EDAM function.
	//
	// @param authenticationToken the authentication token to revoke.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
	//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
	//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
	//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
	//     is already revoked.
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	RevokeLongSession(authenticationToken string) (err error)
	// This is used to take an existing authentication token that grants access
	// to an individual user account (returned from 'authenticate',
	// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
	// authentication token that may be used to access business notebooks if the user
	// is a member of an Evernote Business account.
	//
	// The resulting authentication token may be used to make NoteStore API calls
	// against the business using the NoteStore URL returned in the result.
	//
	// @param authenticationToken
	//   The authentication token for the user. This may not be a shared authentication
	//   token (returned by NoteStore.authenticateToSharedNotebook or
	//   NoteStore.authenticateToSharedNote) or a business authentication token.
	//
	// @return
	//   The result of the authentication, with the token granting access to the
	//   business in the result's 'authenticationToken' field. The URL that must
	//   be used to access the business account NoteStore will be returned in the
	//   result's 'noteStoreUrl' field.  The 'User' field will
	//   not be set in the result.
	//
	// @throws EDAMUserException <ul>
	//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
	//        is a shared or business authentication token. </li>
	//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
	//        authentication token is not currently a member of a business. </li>
	//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
	//        member of is not currently in an active status. </li>
	//   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
	//        sign-on before authenticating to the business.
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult_, err error)
	// Returns the User corresponding to the provided authentication token,
	// or throws an exception if this token is not valid.
	// The level of detail provided in the returned User structure depends on
	// the access level granted by the token, so a web service client may receive
	// fewer fields than an integrated desktop client.
	//
	// Parameters:
	//  - AuthenticationToken
	GetUser(authenticationToken string) (r *types.User, err error)
	// Asks the UserStore about the publicly available location information for
	// a particular username.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "username" - username is empty
	// </ul>
	//
	// Parameters:
	//  - Username
	GetPublicUserInfo(username string) (r *PublicUserInfo, err error)
	// <p>Returns the URLs that should be used when sending requests to the service on
	// behalf of the account represented by the provided authenticationToken.</p>
	//
	// <p>This method isn't needed by most clients, who can retreive the correct set of
	// UserUrls from the AuthenticationResult returned from
	// UserStore#authenticateLongSession(). This method is typically only needed to look up
	// the correct URLs for an existing long-lived authentication token.</p>
	//
	// Parameters:
	//  - AuthenticationToken
	GetUserUrls(authenticationToken string) (r *UserUrls, err error)
	// Invite a user to join an Evernote Business account.
	//
	// Behavior will depend on the auth token. <ol>
	//   <li>
	//     auth token with privileges to manage Evernote Business membership.
	//       "External Provisioning" - The user will receive an email inviting
	//       them to join the business. They do not need to have an existing Evernote
	//       account. If the user has already been invited, a new invitation email
	//       will be sent.
	//   </li>
	//   <li>
	//     business auth token issued to an admin user. Only for first-party clients:
	//       "Approve Invitation" - If there has been a request to invite the email,
	//       approve it. Invited user will receive email with a link to join business.
	//       "Invite User" - If no invitation for the email exists, create an approved
	//       invitation for the email. An email will be sent to the emailAddress with
	//       a link to join the caller's business.
	//   </li>
	//   </li>
	//     business auth token:
	//       "Request Invitation" - If no invitation exists, create a request to
	//       invite the user to the business. These requests do not count towards a
	//       business' max active user limit.
	//   </li>
	// </ol>
	//
	// @param authenticationToken
	//   the authentication token with sufficient privileges to manage Evernote Business
	//   membership or a business auth token.
	//
	// @param emailAddress
	//   the email address of the user to invite to join the Evernote Business account.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
	//   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
	//   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
	//     whose business email address matches the specified email address. </li>
	//   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
	//     user limit. </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - EmailAddress
	InviteToBusiness(authenticationToken string, emailAddress string) (err error)
	// Remove a user from an Evernote Business account. Once removed, the user will no
	// longer be able to access content within the Evernote Business account.
	//
	// <p>The email address of the user to remove from the business must match the email
	// address used to invite a user to join the business via UserStore.inviteToBusiness.
	// This function will only remove users who were invited by external provisioning</p>
	//
	// @param authenticationToken
	//   An authentication token with sufficient privileges to manage Evernote Business
	//   membership.
	//
	// @param emailAddress
	//   The email address of the user to remove from the Evernote Business account.
	//
	// @throws EDAMUserException <ul>
	//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
	//   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
	// </ul>
	// @throws EDAMNotFoundException <ul>
	//   <li> "email" - If there is no user with the specified email address in the
	//     business or that user was not invited via external provisioning. </li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - EmailAddress
	RemoveFromBusiness(authenticationToken string, emailAddress string) (err error)
	// Update the email address used to uniquely identify an Evernote Business user.
	//
	// This will update the identifier for a user who was previously invited using
	// inviteToBusiness, ensuring that caller and the Evernote service maintain an
	// agreed-upon identifier for a specific user.
	//
	// For example, the following sequence of calls would invite a user to join
	// a business, update their email address, and then remove the user
	// from the business using the updated email address.
	//
	// inviteToBusiness("foo@bar.com")
	// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
	// removeFromBusiness("baz@bar.com")
	//
	// @param authenticationToken
	//   An authentication token with sufficient privileges to manage Evernote Business
	//   membership.
	//
	// @param oldEmailAddress
	//   The existing email address used to uniquely identify the user.
	//
	// @param newEmailAddress
	//   The new email address used to uniquely identify the user.
	//
	// @throws EDAMUserException <ul>
	//   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
	//   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
	//   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
	//   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
	//   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
	//   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
	//     the provided new email address.</li>
	//   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
	//     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
	//     updated.</li>
	// </ul>
	// @throws EDAMNotFoundException <ul>
	//   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
	//     in the business.</li>
	// </ul>
	//
	// Parameters:
	//  - AuthenticationToken
	//  - OldEmailAddress
	//  - NewEmailAddress_
	UpdateBusinessUserIdentifier(authenticationToken string, oldEmailAddress string, newEmailAddress string) (err error)
	// Returns a list of active business users in a given business.
	//
	// Clients are required to cache this information and re-fetch no more than once per day
	// or when they encountered a user ID or username that was not known to them.
	//
	// To avoid excessive look ups, clients should also track user IDs and usernames that belong
	// to users who are not in the business, since they will not be included in the result.
	//
	// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
	// listBusinessUsers to find information about this user. If the user is not in the resulting
	// list, the client should track that fact and not re-query the service the next time that it sees
	// this user on a note.
	//
	// @param authenticationToken
	//   A business authentication token returned by authenticateToBusiness or with sufficient
	//   privileges to manage Evernote Business membership.
	//
	// Parameters:
	//  - AuthenticationToken
	ListBusinessUsers(authenticationToken string) (r []*types.UserProfile, err error)
	// Returns a list of outstanding invitations to join an Evernote Business account.
	//
	// Only outstanding invitations are returned by this function. Users who have accepted an
	// invitation and joined a business are listed using listBusinessUsers.
	//
	// @param authenticationToken
	//   An authentication token with sufficient privileges to manage Evernote Business membership.
	//
	// @param includeRequestedInvitations
	//   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
	//   in the returned list. If false, only invitations with a status of
	//   BusinessInvitationStatus.APPROVED will be included.
	//
	// Parameters:
	//  - AuthenticationToken
	//  - IncludeRequestedInvitations
	ListBusinessInvitations(authenticationToken string, includeRequestedInvitations bool) (r []*types.BusinessInvitation, err error)
	// Retrieve the standard account limits for a given service level. This should only be
	// called when necessary, e.g. to determine if a higher level is available should the
	// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
	// not expected to fluctuate frequently.
	//
	// @throws EDAMUserException <ul>
	//   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
	// </ul>
	//
	// Parameters:
	//  - ServiceLevel
	GetAccountLimits(serviceLevel types.ServiceLevel) (r *types.AccountLimits, err error)
}

//Service:  UserStore
//<p>
//The UserStore service is primarily used by EDAM clients to establish
//authentication via username and password over a trusted connection (e.g.
//SSL).  A client's first call to this interface should be checkVersion() to
//ensure that the client's software is up to date.
//</p>
//All calls which require an authenticationToken may throw an
//EDAMUserException for the following reasons:
// <ul>
//  <li> AUTH_EXPIRED "authenticationToken" - token has expired
//  <li> BAD_DATA_FORMAT "authenticationToken" - token is malformed
//  <li> DATA_REQUIRED "authenticationToken" - token is empty
//  <li> INVALID_AUTH "authenticationToken" - token signature is invalid
//  <li> PERMISSION_DENIED "authenticationToken" - token does not convey sufficient
//    privileges
//</ul>
type UserStoreClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewUserStoreClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewUserStoreClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *UserStoreClient {
	return &UserStoreClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// This should be the first call made by a client to the EDAM service.  It
// tells the service what protocol version is used by the client.  The
// service will then return true if the client is capable of talking to
// the service, and false if the client's protocol version is incompatible
// with the service, so the client must upgrade.  If a client receives a
// false value, it should report the incompatibility to the user and not
// continue with any more EDAM requests (UserStore or NoteStore).
//
// @param clientName
//   This string provides some information about the client for
//   tracking/logging on the service.  It should provide information about
//   the client's software and platform. The structure should be:
//   application/version; platform/version; [ device/version ]
//   E.g. "Evernote Windows/3.0.1; Windows/XP SP3".
//
// @param edamVersionMajor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MAJOR
//   constant for the client.
//
// @param edamVersionMinor
//   This should be the major protocol version that was compiled by the
//   client.  This should be the current value of the EDAM_VERSION_MINOR
//   constant for the client.
//
// Parameters:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
func (p *UserStoreClient) CheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (r bool, err error) {
	if err = p.sendCheckVersion(clientName, edamVersionMajor, edamVersionMinor); err != nil {
		return
	}
	return p.recvCheckVersion()
}

func (p *UserStoreClient) sendCheckVersion(clientName string, edamVersionMajor int16, edamVersionMinor int16) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkVersion", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreCheckVersionArgs{
		ClientName:       clientName,
		EdamVersionMajor: edamVersionMajor,
		EdamVersionMinor: edamVersionMinor,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvCheckVersion() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "checkVersion" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "checkVersion failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkVersion failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error1 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error2 error
		error2, err = error1.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error2
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "checkVersion failed: invalid message type")
		return
	}
	result := UserStoreCheckVersionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// This provides bootstrap information to the client. Various bootstrap
// profiles and settings may be used by the client to configure itself.
//
// @param locale
//   The client's current locale, expressed in language[_country]
//   format. E.g., "en_US". See ISO-639 and ISO-3166 for valid
//   language and country codes.
//
// @return
//   The bootstrap information suitable for this client.
//
// Parameters:
//  - Locale
func (p *UserStoreClient) GetBootstrapInfo(locale string) (r *BootstrapInfo, err error) {
	if err = p.sendGetBootstrapInfo(locale); err != nil {
		return
	}
	return p.recvGetBootstrapInfo()
}

func (p *UserStoreClient) sendGetBootstrapInfo(locale string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getBootstrapInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetBootstrapInfoArgs{
		Locale: locale,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetBootstrapInfo() (value *BootstrapInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getBootstrapInfo" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getBootstrapInfo failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getBootstrapInfo failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error3 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error4 error
		error4, err = error3.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error4
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getBootstrapInfo failed: invalid message type")
		return
	}
	result := UserStoreGetBootstrapInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// This is used to check a username and password in order to create a
// long-lived authentication token that can be used for further actions.
//
// This function is not available to most third party applications,
// which typically authenticate using OAuth as
// described at
// <a href="http://dev.evernote.com/documentation/cloud/">dev.evernote.com</a>.
// If you believe that your application requires permission to authenticate
// using username and password instead of OAuth, please contact Evernote
// developer support by visiting
// <a href="http://dev.evernote.com">dev.evernote.com</a>.
//
// @param username
//   The username or registered email address of the account to
//   authenticate against.
//
// @param password
//   The plaintext password to check against the account.  Since
//   this is not protected by the EDAM protocol, this information must be
//   provided over a protected transport (i.e. SSL).
//
// @param consumerKey
//   The "consumer key" portion of the API key issued to the client application
//   by Evernote.
//
// @param consumerSecret
//   The "consumer secret" portion of the API key issued to the client application
//   by Evernote.
//
// @param deviceIdentifier
//   An optional string that uniquely identifies the device from which the
//   authentication is being performed. This string allows the service to return the
//   same authentication token when a given application requests authentication
//   repeatedly from the same device. This may happen when the user logs out of an
//   application and then logs back in, or when the application is uninstalled
//   and later reinstalled. If no reliable device identifier can be created,
//   this value should be omitted. If set, the device identifier must be between
//   1 and EDAM_DEVICE_ID_LEN_MAX characters long and must match the regular expression
//   EDAM_DEVICE_ID_REGEX.
//
// @param deviceDescription
//   A description of the device from which the authentication is being performed.
//   This field is displayed to the user in a list of authorized applications to
//   allow them to distinguish between multiple tokens issued to the same client
//   application on different devices. For example, the Evernote iOS client on
//   a user's iPhone and iPad might pass the iOS device names "Bob's iPhone" and
//   "Bob's iPad". The device description must be between 1 and
//   EDAM_DEVICE_DESCRIPTION_LEN_MAX characters long and must match the regular
//   expression EDAM_DEVICE_DESCRIPTION_REGEX.
//
// @param supportsTwoFactor
//   Whether the calling application supports two-factor authentication. If this
//   parameter is false, this method will fail with the error code INVALID_AUTH and the
//   parameter "password" when called for a user who has enabled two-factor
//   authentication.
//
// @return
//   <p>The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by
//   calling application's API key.</p>
//   <p>If the user has two-factor authentication enabled,
//   AuthenticationResult.secondFactorRequired will be set and
//   AuthenticationResult.authenticationToken will contain a short-lived token
//   that may only be used to complete the two-factor authentication process by calling
//   UserStore.completeTwoFactorAuthentication.</p>
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
//   <li> DATA_REQUIRED "password" - password is empty
//   <li> DATA_REQUIRED "consumerKey" - consumerKey is empty
//   <li> DATA_REQUIRED "consumerSecret" - consumerSecret is empty
//   <li> DATA_REQUIRED "deviceDescription" - deviceDescription is empty
//   <li> BAD_DATA_FORMAT "deviceDescription" - deviceDescription is not valid.
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid.
//   <li> INVALID_AUTH "username" - username not found
//   <li> INVALID_AUTH "password" - password did not match
//   <li> INVALID_AUTH "consumerKey" - consumerKey is not authorized
//   <li> INVALID_AUTH "consumerSecret" - consumerSecret is incorrect
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> AUTH_EXPIRED "password" - user password is expired
// </ul>
//
// Parameters:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
func (p *UserStoreClient) AuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (r *AuthenticationResult_, err error) {
	if err = p.sendAuthenticateLongSession(username, password, consumerKey, consumerSecret, deviceIdentifier, deviceDescription, supportsTwoFactor); err != nil {
		return
	}
	return p.recvAuthenticateLongSession()
}

func (p *UserStoreClient) sendAuthenticateLongSession(username string, password string, consumerKey string, consumerSecret string, deviceIdentifier string, deviceDescription string, supportsTwoFactor bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("authenticateLongSession", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreAuthenticateLongSessionArgs{
		Username:          username,
		Password:          password,
		ConsumerKey:       consumerKey,
		ConsumerSecret:    consumerSecret,
		DeviceIdentifier:  deviceIdentifier,
		DeviceDescription: deviceDescription,
		SupportsTwoFactor: supportsTwoFactor,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvAuthenticateLongSession() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "authenticateLongSession" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "authenticateLongSession failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "authenticateLongSession failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error6 error
		error6, err = error5.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error6
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "authenticateLongSession failed: invalid message type")
		return
	}
	result := UserStoreAuthenticateLongSessionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Complete the authentication process when a second factor is required. This
// call is made after a successful call to authenticate or authenticateLongSession
// when the authenticating user has enabled two-factor authentication.
//
// @param authenticationToken An authentication token returned by a previous
//   call to UserStore.authenticate or UserStore.authenticateLongSession that
//   could not be completed in a single call because a second factor was required.
//
// @param oneTimeCode The one time code entered by the user. This value is delivered
//   out-of-band, typically via SMS or an authenticator application.
//
// @param deviceIdentifier See the corresponding parameter in authenticateLongSession.
//
// @param deviceDescription See the corresponding parameter in authenticateLongSession.
//
// @return
//   The result of the authentication. The level of detail provided in the returned
//   AuthenticationResult.User structure depends on the access level granted by the
//   calling application's API key. If the initial authentication call was made to
//   authenticateLongSession, the AuthenticationResult will contain a long-lived
//   authentication token.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - authenticationToken is empty
//   <li> DATA_REQUIRED "oneTimeCode" - oneTimeCode is empty
//   <li> BAD_DATA_FORMAT "deviceIdentifier" - deviceIdentifier is not valid
//   <li> BAD_DATA_FORMAT "authenticationToken" - authenticationToken is not well formed
//   <li> INVALID_AUTH "oneTimeCode" - oneTimeCode did not match
//   <li> AUTH_EXPIRED "authenticationToken" - authenticationToken has expired
//   <li> PERMISSION_DENIED "authenticationToken" - authenticationToken is not valid
//   <li> PERMISSION_DENIED "User.active" - user account is closed
//   <li> PERMISSION_DENIED "User.tooManyFailuresTryAgainLater" - user has
//     failed authentication too often
//   <li> DATA_CONFLICT "User.twoFactorAuthentication" - The user has not enabled
//      two-factor authentication.</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
func (p *UserStoreClient) CompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (r *AuthenticationResult_, err error) {
	if err = p.sendCompleteTwoFactorAuthentication(authenticationToken, oneTimeCode, deviceIdentifier, deviceDescription); err != nil {
		return
	}
	return p.recvCompleteTwoFactorAuthentication()
}

func (p *UserStoreClient) sendCompleteTwoFactorAuthentication(authenticationToken string, oneTimeCode string, deviceIdentifier string, deviceDescription string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreCompleteTwoFactorAuthenticationArgs{
		AuthenticationToken: authenticationToken,
		OneTimeCode:         oneTimeCode,
		DeviceIdentifier:    deviceIdentifier,
		DeviceDescription:   deviceDescription,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvCompleteTwoFactorAuthentication() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "completeTwoFactorAuthentication" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "completeTwoFactorAuthentication failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "completeTwoFactorAuthentication failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error7 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error8 error
		error8, err = error7.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error8
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "completeTwoFactorAuthentication failed: invalid message type")
		return
	}
	result := UserStoreCompleteTwoFactorAuthenticationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Revoke an existing long lived authentication token. This can be used to
// revoke OAuth tokens or tokens created by calling authenticateLongSession,
// and allows a user to effectively log out of Evernote from the perspective
// of the application that holds the token. The authentication token that is
// passed is immediately revoked and may not be used to call any authenticated
// EDAM function.
//
// @param authenticationToken the authentication token to revoke.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "authenticationToken" - no authentication token provided
//   <li> BAD_DATA_FORMAT "authenticationToken" - the authentication token is not well formed
//   <li> INVALID_AUTH "authenticationToken" - the authentication token is invalid
//   <li> AUTH_EXPIRED "authenticationToken" - the authentication token is expired or
//     is already revoked.
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) RevokeLongSession(authenticationToken string) (err error) {
	if err = p.sendRevokeLongSession(authenticationToken); err != nil {
		return
	}
	return p.recvRevokeLongSession()
}

func (p *UserStoreClient) sendRevokeLongSession(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("revokeLongSession", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreRevokeLongSessionArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvRevokeLongSession() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "revokeLongSession" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "revokeLongSession failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "revokeLongSession failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error9 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error10 error
		error10, err = error9.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error10
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "revokeLongSession failed: invalid message type")
		return
	}
	result := UserStoreRevokeLongSessionResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	return
}

// This is used to take an existing authentication token that grants access
// to an individual user account (returned from 'authenticate',
// 'authenticateLongSession' or an OAuth authorization) and obtain an additional
// authentication token that may be used to access business notebooks if the user
// is a member of an Evernote Business account.
//
// The resulting authentication token may be used to make NoteStore API calls
// against the business using the NoteStore URL returned in the result.
//
// @param authenticationToken
//   The authentication token for the user. This may not be a shared authentication
//   token (returned by NoteStore.authenticateToSharedNotebook or
//   NoteStore.authenticateToSharedNote) or a business authentication token.
//
// @return
//   The result of the authentication, with the token granting access to the
//   business in the result's 'authenticationToken' field. The URL that must
//   be used to access the business account NoteStore will be returned in the
//   result's 'noteStoreUrl' field.  The 'User' field will
//   not be set in the result.
//
// @throws EDAMUserException <ul>
//   <li> PERMISSION_DENIED "authenticationToken" - the provided authentication token
//        is a shared or business authentication token. </li>
//   <li> PERMISSION_DENIED "Business" - the user identified by the provided
//        authentication token is not currently a member of a business. </li>
//   <li> PERMISSION_DENIED "Business.status" - the business that the user is a
//        member of is not currently in an active status. </li>
//   <li> BUSINESS_SECURITY_LOGIN_REQUIRED "sso" - the user must complete single
//        sign-on before authenticating to the business.
// </ul>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) AuthenticateToBusiness(authenticationToken string) (r *AuthenticationResult_, err error) {
	if err = p.sendAuthenticateToBusiness(authenticationToken); err != nil {
		return
	}
	return p.recvAuthenticateToBusiness()
}

func (p *UserStoreClient) sendAuthenticateToBusiness(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("authenticateToBusiness", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreAuthenticateToBusinessArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvAuthenticateToBusiness() (value *AuthenticationResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "authenticateToBusiness" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "authenticateToBusiness failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "authenticateToBusiness failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "authenticateToBusiness failed: invalid message type")
		return
	}
	result := UserStoreAuthenticateToBusinessResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Returns the User corresponding to the provided authentication token,
// or throws an exception if this token is not valid.
// The level of detail provided in the returned User structure depends on
// the access level granted by the token, so a web service client may receive
// fewer fields than an integrated desktop client.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUser(authenticationToken string) (r *types.User, err error) {
	if err = p.sendGetUser(authenticationToken); err != nil {
		return
	}
	return p.recvGetUser()
}

func (p *UserStoreClient) sendGetUser(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getUser", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetUserArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetUser() (value *types.User, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getUser" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getUser failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getUser failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error13 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error14 error
		error14, err = error13.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error14
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getUser failed: invalid message type")
		return
	}
	result := UserStoreGetUserResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Asks the UserStore about the publicly available location information for
// a particular username.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "username" - username is empty
// </ul>
//
// Parameters:
//  - Username
func (p *UserStoreClient) GetPublicUserInfo(username string) (r *PublicUserInfo, err error) {
	if err = p.sendGetPublicUserInfo(username); err != nil {
		return
	}
	return p.recvGetPublicUserInfo()
}

func (p *UserStoreClient) sendGetPublicUserInfo(username string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getPublicUserInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetPublicUserInfoArgs{
		Username: username,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetPublicUserInfo() (value *PublicUserInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getPublicUserInfo" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getPublicUserInfo failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getPublicUserInfo failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getPublicUserInfo failed: invalid message type")
		return
	}
	result := UserStoreGetPublicUserInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.NotFoundException != nil {
		err = result.NotFoundException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	} else if result.UserException != nil {
		err = result.UserException
		return
	}
	value = result.GetSuccess()
	return
}

// <p>Returns the URLs that should be used when sending requests to the service on
// behalf of the account represented by the provided authenticationToken.</p>
//
// <p>This method isn't needed by most clients, who can retreive the correct set of
// UserUrls from the AuthenticationResult returned from
// UserStore#authenticateLongSession(). This method is typically only needed to look up
// the correct URLs for an existing long-lived authentication token.</p>
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) GetUserUrls(authenticationToken string) (r *UserUrls, err error) {
	if err = p.sendGetUserUrls(authenticationToken); err != nil {
		return
	}
	return p.recvGetUserUrls()
}

func (p *UserStoreClient) sendGetUserUrls(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getUserUrls", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetUserUrlsArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetUserUrls() (value *UserUrls, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getUserUrls" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getUserUrls failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getUserUrls failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error17 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error18 error
		error18, err = error17.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error18
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getUserUrls failed: invalid message type")
		return
	}
	result := UserStoreGetUserUrlsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Invite a user to join an Evernote Business account.
//
// Behavior will depend on the auth token. <ol>
//   <li>
//     auth token with privileges to manage Evernote Business membership.
//       "External Provisioning" - The user will receive an email inviting
//       them to join the business. They do not need to have an existing Evernote
//       account. If the user has already been invited, a new invitation email
//       will be sent.
//   </li>
//   <li>
//     business auth token issued to an admin user. Only for first-party clients:
//       "Approve Invitation" - If there has been a request to invite the email,
//       approve it. Invited user will receive email with a link to join business.
//       "Invite User" - If no invitation for the email exists, create an approved
//       invitation for the email. An email will be sent to the emailAddress with
//       a link to join the caller's business.
//   </li>
//   </li>
//     business auth token:
//       "Request Invitation" - If no invitation exists, create a request to
//       invite the user to the business. These requests do not count towards a
//       business' max active user limit.
//   </li>
// </ol>
//
// @param authenticationToken
//   the authentication token with sufficient privileges to manage Evernote Business
//   membership or a business auth token.
//
// @param emailAddress
//   the email address of the user to invite to join the Evernote Business account.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
//   <li> BAD_DATA_FORMAT "email" - if the email address is not well formed </li>
//   <li> DATA_CONFLICT "BusinessUser.email" - if there is already a user in the business
//     whose business email address matches the specified email address. </li>
//   <li> LIMIT_REACHED "Business.maxActiveUsers" - if the business has reached its
//     user limit. </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - EmailAddress
func (p *UserStoreClient) InviteToBusiness(authenticationToken string, emailAddress string) (err error) {
	if err = p.sendInviteToBusiness(authenticationToken, emailAddress); err != nil {
		return
	}
	return p.recvInviteToBusiness()
}

func (p *UserStoreClient) sendInviteToBusiness(authenticationToken string, emailAddress string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("inviteToBusiness", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreInviteToBusinessArgs{
		AuthenticationToken: authenticationToken,
		EmailAddress:        emailAddress,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvInviteToBusiness() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "inviteToBusiness" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "inviteToBusiness failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "inviteToBusiness failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error19 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error20 error
		error20, err = error19.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error20
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "inviteToBusiness failed: invalid message type")
		return
	}
	result := UserStoreInviteToBusinessResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	return
}

// Remove a user from an Evernote Business account. Once removed, the user will no
// longer be able to access content within the Evernote Business account.
//
// <p>The email address of the user to remove from the business must match the email
// address used to invite a user to join the business via UserStore.inviteToBusiness.
// This function will only remove users who were invited by external provisioning</p>
//
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business
//   membership.
//
// @param emailAddress
//   The email address of the user to remove from the Evernote Business account.
//
// @throws EDAMUserException <ul>
//   <li> DATA_REQUIRED "email" - if no email address was provided </li>
//   <li> BAD_DATA_FORMAT "email" - The email address is not well formed </li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li> "email" - If there is no user with the specified email address in the
//     business or that user was not invited via external provisioning. </li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - EmailAddress
func (p *UserStoreClient) RemoveFromBusiness(authenticationToken string, emailAddress string) (err error) {
	if err = p.sendRemoveFromBusiness(authenticationToken, emailAddress); err != nil {
		return
	}
	return p.recvRemoveFromBusiness()
}

func (p *UserStoreClient) sendRemoveFromBusiness(authenticationToken string, emailAddress string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("removeFromBusiness", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreRemoveFromBusinessArgs{
		AuthenticationToken: authenticationToken,
		EmailAddress:        emailAddress,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvRemoveFromBusiness() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "removeFromBusiness" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "removeFromBusiness failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "removeFromBusiness failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error21 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error22 error
		error22, err = error21.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error22
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "removeFromBusiness failed: invalid message type")
		return
	}
	result := UserStoreRemoveFromBusinessResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	} else if result.NotFoundException != nil {
		err = result.NotFoundException
		return
	}
	return
}

// Update the email address used to uniquely identify an Evernote Business user.
//
// This will update the identifier for a user who was previously invited using
// inviteToBusiness, ensuring that caller and the Evernote service maintain an
// agreed-upon identifier for a specific user.
//
// For example, the following sequence of calls would invite a user to join
// a business, update their email address, and then remove the user
// from the business using the updated email address.
//
// inviteToBusiness("foo@bar.com")
// updateBusinessUserIdentifier("foo@bar.com", "baz@bar.com")
// removeFromBusiness("baz@bar.com")
//
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business
//   membership.
//
// @param oldEmailAddress
//   The existing email address used to uniquely identify the user.
//
// @param newEmailAddress
//   The new email address used to uniquely identify the user.
//
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "oldEmailAddress" - No old email address was provided</li>
//   <li>DATA_REQUIRED "newEmailAddress" - No new email address was provided</li>
//   <li>BAD_DATA_FORMAT "oldEmailAddress" - The old email address is not well formed</li>
//   <li>BAD_DATA_FORMAT "newEmailAddress" - The new email address is not well formed</li>
//   <li>DATA_CONFLICT "oldEmailAddress" - The old and new email addresses were the same</li>
//   <li>DATA_CONFLICT "newEmailAddress" - There is already an invitation or registered user with
//     the provided new email address.</li>
//   <li>DATA_CONFLICT "invitation.externallyProvisioned" - The user identified by
//     oldEmailAddress was not added via UserStore.inviteToBusiness and therefore cannot be
//     updated.</li>
// </ul>
// @throws EDAMNotFoundException <ul>
//   <li>"oldEmailAddress" - If there is no user or invitation with the specified oldEmailAddress
//     in the business.</li>
// </ul>
//
// Parameters:
//  - AuthenticationToken
//  - OldEmailAddress
//  - NewEmailAddress_
func (p *UserStoreClient) UpdateBusinessUserIdentifier(authenticationToken string, oldEmailAddress string, newEmailAddress string) (err error) {
	if err = p.sendUpdateBusinessUserIdentifier(authenticationToken, oldEmailAddress, newEmailAddress); err != nil {
		return
	}
	return p.recvUpdateBusinessUserIdentifier()
}

func (p *UserStoreClient) sendUpdateBusinessUserIdentifier(authenticationToken string, oldEmailAddress string, newEmailAddress string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreUpdateBusinessUserIdentifierArgs{
		AuthenticationToken: authenticationToken,
		OldEmailAddress:     oldEmailAddress,
		NewEmailAddress_:    newEmailAddress,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvUpdateBusinessUserIdentifier() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "updateBusinessUserIdentifier" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "updateBusinessUserIdentifier failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "updateBusinessUserIdentifier failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "updateBusinessUserIdentifier failed: invalid message type")
		return
	}
	result := UserStoreUpdateBusinessUserIdentifierResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	} else if result.NotFoundException != nil {
		err = result.NotFoundException
		return
	}
	return
}

// Returns a list of active business users in a given business.
//
// Clients are required to cache this information and re-fetch no more than once per day
// or when they encountered a user ID or username that was not known to them.
//
// To avoid excessive look ups, clients should also track user IDs and usernames that belong
// to users who are not in the business, since they will not be included in the result.
//
// I.e., when a client encounters a previously unknown user ID as a note's creator, it may query
// listBusinessUsers to find information about this user. If the user is not in the resulting
// list, the client should track that fact and not re-query the service the next time that it sees
// this user on a note.
//
// @param authenticationToken
//   A business authentication token returned by authenticateToBusiness or with sufficient
//   privileges to manage Evernote Business membership.
//
// Parameters:
//  - AuthenticationToken
func (p *UserStoreClient) ListBusinessUsers(authenticationToken string) (r []*types.UserProfile, err error) {
	if err = p.sendListBusinessUsers(authenticationToken); err != nil {
		return
	}
	return p.recvListBusinessUsers()
}

func (p *UserStoreClient) sendListBusinessUsers(authenticationToken string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("listBusinessUsers", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreListBusinessUsersArgs{
		AuthenticationToken: authenticationToken,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvListBusinessUsers() (value []*types.UserProfile, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "listBusinessUsers" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "listBusinessUsers failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "listBusinessUsers failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error25 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error26 error
		error26, err = error25.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error26
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "listBusinessUsers failed: invalid message type")
		return
	}
	result := UserStoreListBusinessUsersResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Returns a list of outstanding invitations to join an Evernote Business account.
//
// Only outstanding invitations are returned by this function. Users who have accepted an
// invitation and joined a business are listed using listBusinessUsers.
//
// @param authenticationToken
//   An authentication token with sufficient privileges to manage Evernote Business membership.
//
// @param includeRequestedInvitations
//   If true, invitations with a status of BusinessInvitationStatus.REQUESTED will be included
//   in the returned list. If false, only invitations with a status of
//   BusinessInvitationStatus.APPROVED will be included.
//
// Parameters:
//  - AuthenticationToken
//  - IncludeRequestedInvitations
func (p *UserStoreClient) ListBusinessInvitations(authenticationToken string, includeRequestedInvitations bool) (r []*types.BusinessInvitation, err error) {
	if err = p.sendListBusinessInvitations(authenticationToken, includeRequestedInvitations); err != nil {
		return
	}
	return p.recvListBusinessInvitations()
}

func (p *UserStoreClient) sendListBusinessInvitations(authenticationToken string, includeRequestedInvitations bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("listBusinessInvitations", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreListBusinessInvitationsArgs{
		AuthenticationToken:         authenticationToken,
		IncludeRequestedInvitations: includeRequestedInvitations,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvListBusinessInvitations() (value []*types.BusinessInvitation, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "listBusinessInvitations" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "listBusinessInvitations failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "listBusinessInvitations failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error27 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error28 error
		error28, err = error27.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error28
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "listBusinessInvitations failed: invalid message type")
		return
	}
	result := UserStoreListBusinessInvitationsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	} else if result.SystemException != nil {
		err = result.SystemException
		return
	}
	value = result.GetSuccess()
	return
}

// Retrieve the standard account limits for a given service level. This should only be
// called when necessary, e.g. to determine if a higher level is available should the
// user upgrade, and should be cached for long periods (e.g. 30 days) as the values are
// not expected to fluctuate frequently.
//
// @throws EDAMUserException <ul>
//   <li>DATA_REQUIRED "serviceLevel" - serviceLevel is null</li>
// </ul>
//
// Parameters:
//  - ServiceLevel
func (p *UserStoreClient) GetAccountLimits(serviceLevel types.ServiceLevel) (r *types.AccountLimits, err error) {
	if err = p.sendGetAccountLimits(serviceLevel); err != nil {
		return
	}
	return p.recvGetAccountLimits()
}

func (p *UserStoreClient) sendGetAccountLimits(serviceLevel types.ServiceLevel) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getAccountLimits", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := UserStoreGetAccountLimitsArgs{
		ServiceLevel: serviceLevel,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *UserStoreClient) recvGetAccountLimits() (value *types.AccountLimits, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	method, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if method != "getAccountLimits" {
		err = thrift.NewTApplicationException(thrift.WRONG_METHOD_NAME, "getAccountLimits failed: wrong method name")
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getAccountLimits failed: out of sequence response")
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error29 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error30 error
		error30, err = error29.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error30
		return
	}
	if mTypeId != thrift.REPLY {
		err = thrift.NewTApplicationException(thrift.INVALID_MESSAGE_TYPE_EXCEPTION, "getAccountLimits failed: invalid message type")
		return
	}
	result := UserStoreGetAccountLimitsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.UserException != nil {
		err = result.UserException
		return
	}
	value = result.GetSuccess()
	return
}

type UserStoreProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      UserStore
}

func (p *UserStoreProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *UserStoreProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *UserStoreProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewUserStoreProcessor(handler UserStore) *UserStoreProcessor {

	self31 := &UserStoreProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self31.processorMap["checkVersion"] = &userStoreProcessorCheckVersion{handler: handler}
	self31.processorMap["getBootstrapInfo"] = &userStoreProcessorGetBootstrapInfo{handler: handler}
	self31.processorMap["authenticateLongSession"] = &userStoreProcessorAuthenticateLongSession{handler: handler}
	self31.processorMap["completeTwoFactorAuthentication"] = &userStoreProcessorCompleteTwoFactorAuthentication{handler: handler}
	self31.processorMap["revokeLongSession"] = &userStoreProcessorRevokeLongSession{handler: handler}
	self31.processorMap["authenticateToBusiness"] = &userStoreProcessorAuthenticateToBusiness{handler: handler}
	self31.processorMap["getUser"] = &userStoreProcessorGetUser{handler: handler}
	self31.processorMap["getPublicUserInfo"] = &userStoreProcessorGetPublicUserInfo{handler: handler}
	self31.processorMap["getUserUrls"] = &userStoreProcessorGetUserUrls{handler: handler}
	self31.processorMap["inviteToBusiness"] = &userStoreProcessorInviteToBusiness{handler: handler}
	self31.processorMap["removeFromBusiness"] = &userStoreProcessorRemoveFromBusiness{handler: handler}
	self31.processorMap["updateBusinessUserIdentifier"] = &userStoreProcessorUpdateBusinessUserIdentifier{handler: handler}
	self31.processorMap["listBusinessUsers"] = &userStoreProcessorListBusinessUsers{handler: handler}
	self31.processorMap["listBusinessInvitations"] = &userStoreProcessorListBusinessInvitations{handler: handler}
	self31.processorMap["getAccountLimits"] = &userStoreProcessorGetAccountLimits{handler: handler}
	return self31
}

func (p *UserStoreProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x32 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x32.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x32

}

type userStoreProcessorCheckVersion struct {
	handler UserStore
}

func (p *userStoreProcessorCheckVersion) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreCheckVersionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreCheckVersionResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckVersion(args.ClientName, args.EdamVersionMajor, args.EdamVersionMinor); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkVersion: "+err2.Error())
		oprot.WriteMessageBegin("checkVersion", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkVersion", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetBootstrapInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetBootstrapInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetBootstrapInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetBootstrapInfoResult{}
	var retval *BootstrapInfo
	var err2 error
	if retval, err2 = p.handler.GetBootstrapInfo(args.Locale); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getBootstrapInfo: "+err2.Error())
		oprot.WriteMessageBegin("getBootstrapInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getBootstrapInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreAuthenticateLongSessionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreAuthenticateLongSessionResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.AuthenticateLongSession(args.Username, args.Password, args.ConsumerKey, args.ConsumerSecret, args.DeviceIdentifier, args.DeviceDescription, args.SupportsTwoFactor); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateLongSession: "+err2.Error())
			oprot.WriteMessageBegin("authenticateLongSession", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("authenticateLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorCompleteTwoFactorAuthentication struct {
	handler UserStore
}

func (p *userStoreProcessorCompleteTwoFactorAuthentication) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreCompleteTwoFactorAuthenticationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreCompleteTwoFactorAuthenticationResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.CompleteTwoFactorAuthentication(args.AuthenticationToken, args.OneTimeCode, args.DeviceIdentifier, args.DeviceDescription); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing completeTwoFactorAuthentication: "+err2.Error())
			oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("completeTwoFactorAuthentication", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRevokeLongSession struct {
	handler UserStore
}

func (p *userStoreProcessorRevokeLongSession) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreRevokeLongSessionArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreRevokeLongSessionResult{}
	var err2 error
	if err2 = p.handler.RevokeLongSession(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing revokeLongSession: "+err2.Error())
			oprot.WriteMessageBegin("revokeLongSession", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("revokeLongSession", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorAuthenticateToBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorAuthenticateToBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreAuthenticateToBusinessArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreAuthenticateToBusinessResult{}
	var retval *AuthenticationResult_
	var err2 error
	if retval, err2 = p.handler.AuthenticateToBusiness(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing authenticateToBusiness: "+err2.Error())
			oprot.WriteMessageBegin("authenticateToBusiness", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("authenticateToBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetUser struct {
	handler UserStore
}

func (p *userStoreProcessorGetUser) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetUserArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetUserResult{}
	var retval *types.User
	var err2 error
	if retval, err2 = p.handler.GetUser(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUser: "+err2.Error())
			oprot.WriteMessageBegin("getUser", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getUser", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetPublicUserInfo struct {
	handler UserStore
}

func (p *userStoreProcessorGetPublicUserInfo) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetPublicUserInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetPublicUserInfoResult{}
	var retval *PublicUserInfo
	var err2 error
	if retval, err2 = p.handler.GetPublicUserInfo(args.Username); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMNotFoundException:
			result.NotFoundException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		case *errors.EDAMUserException:
			result.UserException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getPublicUserInfo: "+err2.Error())
			oprot.WriteMessageBegin("getPublicUserInfo", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getPublicUserInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetUserUrls struct {
	handler UserStore
}

func (p *userStoreProcessorGetUserUrls) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetUserUrlsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getUserUrls", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetUserUrlsResult{}
	var retval *UserUrls
	var err2 error
	if retval, err2 = p.handler.GetUserUrls(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getUserUrls: "+err2.Error())
			oprot.WriteMessageBegin("getUserUrls", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getUserUrls", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorInviteToBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorInviteToBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreInviteToBusinessArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("inviteToBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreInviteToBusinessResult{}
	var err2 error
	if err2 = p.handler.InviteToBusiness(args.AuthenticationToken, args.EmailAddress); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing inviteToBusiness: "+err2.Error())
			oprot.WriteMessageBegin("inviteToBusiness", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("inviteToBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorRemoveFromBusiness struct {
	handler UserStore
}

func (p *userStoreProcessorRemoveFromBusiness) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreRemoveFromBusinessArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("removeFromBusiness", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreRemoveFromBusinessResult{}
	var err2 error
	if err2 = p.handler.RemoveFromBusiness(args.AuthenticationToken, args.EmailAddress); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		case *errors.EDAMNotFoundException:
			result.NotFoundException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing removeFromBusiness: "+err2.Error())
			oprot.WriteMessageBegin("removeFromBusiness", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("removeFromBusiness", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorUpdateBusinessUserIdentifier struct {
	handler UserStore
}

func (p *userStoreProcessorUpdateBusinessUserIdentifier) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreUpdateBusinessUserIdentifierArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreUpdateBusinessUserIdentifierResult{}
	var err2 error
	if err2 = p.handler.UpdateBusinessUserIdentifier(args.AuthenticationToken, args.OldEmailAddress, args.NewEmailAddress_); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		case *errors.EDAMNotFoundException:
			result.NotFoundException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing updateBusinessUserIdentifier: "+err2.Error())
			oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("updateBusinessUserIdentifier", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorListBusinessUsers struct {
	handler UserStore
}

func (p *userStoreProcessorListBusinessUsers) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreListBusinessUsersArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("listBusinessUsers", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreListBusinessUsersResult{}
	var retval []*types.UserProfile
	var err2 error
	if retval, err2 = p.handler.ListBusinessUsers(args.AuthenticationToken); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listBusinessUsers: "+err2.Error())
			oprot.WriteMessageBegin("listBusinessUsers", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("listBusinessUsers", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorListBusinessInvitations struct {
	handler UserStore
}

func (p *userStoreProcessorListBusinessInvitations) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreListBusinessInvitationsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("listBusinessInvitations", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreListBusinessInvitationsResult{}
	var retval []*types.BusinessInvitation
	var err2 error
	if retval, err2 = p.handler.ListBusinessInvitations(args.AuthenticationToken, args.IncludeRequestedInvitations); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		case *errors.EDAMSystemException:
			result.SystemException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing listBusinessInvitations: "+err2.Error())
			oprot.WriteMessageBegin("listBusinessInvitations", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("listBusinessInvitations", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type userStoreProcessorGetAccountLimits struct {
	handler UserStore
}

func (p *userStoreProcessorGetAccountLimits) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := UserStoreGetAccountLimitsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getAccountLimits", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := UserStoreGetAccountLimitsResult{}
	var retval *types.AccountLimits
	var err2 error
	if retval, err2 = p.handler.GetAccountLimits(args.ServiceLevel); err2 != nil {
		switch v := err2.(type) {
		case *errors.EDAMUserException:
			result.UserException = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getAccountLimits: "+err2.Error())
			oprot.WriteMessageBegin("getAccountLimits", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getAccountLimits", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

// Attributes:
//  - ClientName
//  - EdamVersionMajor
//  - EdamVersionMinor
type UserStoreCheckVersionArgs struct {
	ClientName       string `thrift:"clientName,1" json:"clientName"`
	EdamVersionMajor int16  `thrift:"edamVersionMajor,2" json:"edamVersionMajor"`
	EdamVersionMinor int16  `thrift:"edamVersionMinor,3" json:"edamVersionMinor"`
}

func NewUserStoreCheckVersionArgs() *UserStoreCheckVersionArgs {
	return &UserStoreCheckVersionArgs{
		EdamVersionMajor: 1,

		EdamVersionMinor: 28,
	}
}

func (p *UserStoreCheckVersionArgs) GetClientName() string {
	return p.ClientName
}

func (p *UserStoreCheckVersionArgs) GetEdamVersionMajor() int16 {
	return p.EdamVersionMajor
}

func (p *UserStoreCheckVersionArgs) GetEdamVersionMinor() int16 {
	return p.EdamVersionMinor
}
func (p *UserStoreCheckVersionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.ClientName = v
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EdamVersionMajor = v
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI16(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.EdamVersionMinor = v
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCheckVersionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("clientName", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:clientName: ", p), err)
	}
	if err := oprot.WriteString(string(p.ClientName)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.clientName (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:clientName: ", p), err)
	}
	return err
}

func (p *UserStoreCheckVersionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMajor", thrift.I16, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:edamVersionMajor: ", p), err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMajor)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.edamVersionMajor (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:edamVersionMajor: ", p), err)
	}
	return err
}

func (p *UserStoreCheckVersionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("edamVersionMinor", thrift.I16, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:edamVersionMinor: ", p), err)
	}
	if err := oprot.WriteI16(int16(p.EdamVersionMinor)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.edamVersionMinor (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:edamVersionMinor: ", p), err)
	}
	return err
}

func (p *UserStoreCheckVersionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCheckVersionArgs(%+v)", *p)
}

// Attributes:
//  - Success
type UserStoreCheckVersionResult struct {
	Success *bool `thrift:"success,0" json:"success,omitempty"`
}

func NewUserStoreCheckVersionResult() *UserStoreCheckVersionResult {
	return &UserStoreCheckVersionResult{}
}

var UserStoreCheckVersionResult_Success_DEFAULT bool

func (p *UserStoreCheckVersionResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return UserStoreCheckVersionResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *UserStoreCheckVersionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreCheckVersionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCheckVersionResult) readField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 0: ", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *UserStoreCheckVersionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkVersion_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCheckVersionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T.success (0) field write error: ", p), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCheckVersionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCheckVersionResult(%+v)", *p)
}

// Attributes:
//  - Locale
type UserStoreGetBootstrapInfoArgs struct {
	Locale string `thrift:"locale,1" json:"locale"`
}

func NewUserStoreGetBootstrapInfoArgs() *UserStoreGetBootstrapInfoArgs {
	return &UserStoreGetBootstrapInfoArgs{}
}

func (p *UserStoreGetBootstrapInfoArgs) GetLocale() string {
	return p.Locale
}
func (p *UserStoreGetBootstrapInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Locale = v
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("locale", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:locale: ", p), err)
	}
	if err := oprot.WriteString(string(p.Locale)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.locale (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:locale: ", p), err)
	}
	return err
}

func (p *UserStoreGetBootstrapInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetBootstrapInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
type UserStoreGetBootstrapInfoResult struct {
	Success *BootstrapInfo `thrift:"success,0" json:"success,omitempty"`
}

func NewUserStoreGetBootstrapInfoResult() *UserStoreGetBootstrapInfoResult {
	return &UserStoreGetBootstrapInfoResult{}
}

var UserStoreGetBootstrapInfoResult_Success_DEFAULT *BootstrapInfo

func (p *UserStoreGetBootstrapInfoResult) GetSuccess() *BootstrapInfo {
	if !p.IsSetSuccess() {
		return UserStoreGetBootstrapInfoResult_Success_DEFAULT
	}
	return p.Success
}
func (p *UserStoreGetBootstrapInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetBootstrapInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &BootstrapInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getBootstrapInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetBootstrapInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetBootstrapInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetBootstrapInfoResult(%+v)", *p)
}

// Attributes:
//  - Username
//  - Password
//  - ConsumerKey
//  - ConsumerSecret
//  - DeviceIdentifier
//  - DeviceDescription
//  - SupportsTwoFactor
type UserStoreAuthenticateLongSessionArgs struct {
	Username          string `thrift:"username,1" json:"username"`
	Password          string `thrift:"password,2" json:"password"`
	ConsumerKey       string `thrift:"consumerKey,3" json:"consumerKey"`
	ConsumerSecret    string `thrift:"consumerSecret,4" json:"consumerSecret"`
	DeviceIdentifier  string `thrift:"deviceIdentifier,5" json:"deviceIdentifier"`
	DeviceDescription string `thrift:"deviceDescription,6" json:"deviceDescription"`
	SupportsTwoFactor bool   `thrift:"supportsTwoFactor,7" json:"supportsTwoFactor"`
}

func NewUserStoreAuthenticateLongSessionArgs() *UserStoreAuthenticateLongSessionArgs {
	return &UserStoreAuthenticateLongSessionArgs{}
}

func (p *UserStoreAuthenticateLongSessionArgs) GetUsername() string {
	return p.Username
}

func (p *UserStoreAuthenticateLongSessionArgs) GetPassword() string {
	return p.Password
}

func (p *UserStoreAuthenticateLongSessionArgs) GetConsumerKey() string {
	return p.ConsumerKey
}

func (p *UserStoreAuthenticateLongSessionArgs) GetConsumerSecret() string {
	return p.ConsumerSecret
}

func (p *UserStoreAuthenticateLongSessionArgs) GetDeviceIdentifier() string {
	return p.DeviceIdentifier
}

func (p *UserStoreAuthenticateLongSessionArgs) GetDeviceDescription() string {
	return p.DeviceDescription
}

func (p *UserStoreAuthenticateLongSessionArgs) GetSupportsTwoFactor() bool {
	return p.SupportsTwoFactor
}
func (p *UserStoreAuthenticateLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.readField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.readField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.readField7(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Username = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.Password = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.ConsumerKey = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.ConsumerSecret = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 5: ", err)
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField6(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 6: ", err)
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) readField7(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 7: ", err)
	} else {
		p.SupportsTwoFactor = v
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:username: ", p), err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.username (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:username: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("password", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:password: ", p), err)
	}
	if err := oprot.WriteString(string(p.Password)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.password (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:password: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerKey", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:consumerKey: ", p), err)
	}
	if err := oprot.WriteString(string(p.ConsumerKey)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consumerKey (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:consumerKey: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("consumerSecret", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:consumerSecret: ", p), err)
	}
	if err := oprot.WriteString(string(p.ConsumerSecret)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.consumerSecret (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:consumerSecret: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 5); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 5:deviceIdentifier: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceIdentifier (5) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 5:deviceIdentifier: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 6); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 6:deviceDescription: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceDescription (6) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 6:deviceDescription: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("supportsTwoFactor", thrift.BOOL, 7); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 7:supportsTwoFactor: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.SupportsTwoFactor)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.supportsTwoFactor (7) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 7:supportsTwoFactor: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateLongSessionArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreAuthenticateLongSessionResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreAuthenticateLongSessionResult() *UserStoreAuthenticateLongSessionResult {
	return &UserStoreAuthenticateLongSessionResult{}
}

var UserStoreAuthenticateLongSessionResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreAuthenticateLongSessionResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreAuthenticateLongSessionResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreAuthenticateLongSessionResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreAuthenticateLongSessionResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreAuthenticateLongSessionResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreAuthenticateLongSessionResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreAuthenticateLongSessionResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreAuthenticateLongSessionResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreAuthenticateLongSessionResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreAuthenticateLongSessionResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreAuthenticateLongSessionResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreAuthenticateLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateLongSession_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateLongSessionResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateLongSessionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - OneTimeCode
//  - DeviceIdentifier
//  - DeviceDescription
type UserStoreCompleteTwoFactorAuthenticationArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
	OneTimeCode         string `thrift:"oneTimeCode,2" json:"oneTimeCode"`
	DeviceIdentifier    string `thrift:"deviceIdentifier,3" json:"deviceIdentifier"`
	DeviceDescription   string `thrift:"deviceDescription,4" json:"deviceDescription"`
}

func NewUserStoreCompleteTwoFactorAuthenticationArgs() *UserStoreCompleteTwoFactorAuthenticationArgs {
	return &UserStoreCompleteTwoFactorAuthenticationArgs{}
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetOneTimeCode() string {
	return p.OneTimeCode
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetDeviceIdentifier() string {
	return p.DeviceIdentifier
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) GetDeviceDescription() string {
	return p.DeviceDescription
}
func (p *UserStoreCompleteTwoFactorAuthenticationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.readField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.OneTimeCode = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.DeviceIdentifier = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) readField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 4: ", err)
	} else {
		p.DeviceDescription = v
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("oneTimeCode", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:oneTimeCode: ", p), err)
	}
	if err := oprot.WriteString(string(p.OneTimeCode)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.oneTimeCode (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:oneTimeCode: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceIdentifier", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:deviceIdentifier: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceIdentifier)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceIdentifier (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:deviceIdentifier: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("deviceDescription", thrift.STRING, 4); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 4:deviceDescription: ", p), err)
	}
	if err := oprot.WriteString(string(p.DeviceDescription)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.deviceDescription (4) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 4:deviceDescription: ", p), err)
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCompleteTwoFactorAuthenticationArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreCompleteTwoFactorAuthenticationResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreCompleteTwoFactorAuthenticationResult() *UserStoreCompleteTwoFactorAuthenticationResult {
	return &UserStoreCompleteTwoFactorAuthenticationResult{}
}

var UserStoreCompleteTwoFactorAuthenticationResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreCompleteTwoFactorAuthenticationResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreCompleteTwoFactorAuthenticationResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreCompleteTwoFactorAuthenticationResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreCompleteTwoFactorAuthenticationResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreCompleteTwoFactorAuthenticationResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreCompleteTwoFactorAuthenticationResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("completeTwoFactorAuthentication_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreCompleteTwoFactorAuthenticationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreCompleteTwoFactorAuthenticationResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreRevokeLongSessionArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreRevokeLongSessionArgs() *UserStoreRevokeLongSessionArgs {
	return &UserStoreRevokeLongSessionArgs{}
}

func (p *UserStoreRevokeLongSessionArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreRevokeLongSessionArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreRevokeLongSessionArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreRevokeLongSessionArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRevokeLongSessionArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
type UserStoreRevokeLongSessionResult struct {
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreRevokeLongSessionResult() *UserStoreRevokeLongSessionResult {
	return &UserStoreRevokeLongSessionResult{}
}

var UserStoreRevokeLongSessionResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreRevokeLongSessionResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreRevokeLongSessionResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreRevokeLongSessionResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreRevokeLongSessionResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreRevokeLongSessionResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreRevokeLongSessionResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreRevokeLongSessionResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreRevokeLongSessionResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("revokeLongSession_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRevokeLongSessionResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRevokeLongSessionResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRevokeLongSessionResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRevokeLongSessionResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreAuthenticateToBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreAuthenticateToBusinessArgs() *UserStoreAuthenticateToBusinessArgs {
	return &UserStoreAuthenticateToBusinessArgs{}
}

func (p *UserStoreAuthenticateToBusinessArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreAuthenticateToBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateToBusinessArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreAuthenticateToBusinessResult struct {
	Success         *AuthenticationResult_      `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreAuthenticateToBusinessResult() *UserStoreAuthenticateToBusinessResult {
	return &UserStoreAuthenticateToBusinessResult{}
}

var UserStoreAuthenticateToBusinessResult_Success_DEFAULT *AuthenticationResult_

func (p *UserStoreAuthenticateToBusinessResult) GetSuccess() *AuthenticationResult_ {
	if !p.IsSetSuccess() {
		return UserStoreAuthenticateToBusinessResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreAuthenticateToBusinessResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreAuthenticateToBusinessResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreAuthenticateToBusinessResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreAuthenticateToBusinessResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreAuthenticateToBusinessResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreAuthenticateToBusinessResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreAuthenticateToBusinessResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreAuthenticateToBusinessResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreAuthenticateToBusinessResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreAuthenticateToBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &AuthenticationResult_{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("authenticateToBusiness_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreAuthenticateToBusinessResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreAuthenticateToBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreAuthenticateToBusinessResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreGetUserArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreGetUserArgs() *UserStoreGetUserArgs {
	return &UserStoreGetUserArgs{}
}

func (p *UserStoreGetUserArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreGetUserArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetUserArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreGetUserArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetUserArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreGetUserArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetUserArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreGetUserResult struct {
	Success         *types.User                 `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreGetUserResult() *UserStoreGetUserResult {
	return &UserStoreGetUserResult{}
}

var UserStoreGetUserResult_Success_DEFAULT *types.User

func (p *UserStoreGetUserResult) GetSuccess() *types.User {
	if !p.IsSetSuccess() {
		return UserStoreGetUserResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreGetUserResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetUserResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetUserResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreGetUserResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreGetUserResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreGetUserResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreGetUserResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetUserResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetUserResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreGetUserResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &types.User{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreGetUserResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUser_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetUserResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetUserResult(%+v)", *p)
}

// Attributes:
//  - Username
type UserStoreGetPublicUserInfoArgs struct {
	Username string `thrift:"username,1" json:"username"`
}

func NewUserStoreGetPublicUserInfoArgs() *UserStoreGetPublicUserInfoArgs {
	return &UserStoreGetPublicUserInfoArgs{}
}

func (p *UserStoreGetPublicUserInfoArgs) GetUsername() string {
	return p.Username
}
func (p *UserStoreGetPublicUserInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.Username = v
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("username", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:username: ", p), err)
	}
	if err := oprot.WriteString(string(p.Username)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.username (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:username: ", p), err)
	}
	return err
}

func (p *UserStoreGetPublicUserInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetPublicUserInfoArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - NotFoundException
//  - SystemException
//  - UserException
type UserStoreGetPublicUserInfoResult struct {
	Success           *PublicUserInfo               `thrift:"success,0" json:"success,omitempty"`
	NotFoundException *errors.EDAMNotFoundException `thrift:"notFoundException,1" json:"notFoundException,omitempty"`
	SystemException   *errors.EDAMSystemException   `thrift:"systemException,2" json:"systemException,omitempty"`
	UserException     *errors.EDAMUserException     `thrift:"userException,3" json:"userException,omitempty"`
}

func NewUserStoreGetPublicUserInfoResult() *UserStoreGetPublicUserInfoResult {
	return &UserStoreGetPublicUserInfoResult{}
}

var UserStoreGetPublicUserInfoResult_Success_DEFAULT *PublicUserInfo

func (p *UserStoreGetPublicUserInfoResult) GetSuccess() *PublicUserInfo {
	if !p.IsSetSuccess() {
		return UserStoreGetPublicUserInfoResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreGetPublicUserInfoResult_NotFoundException_DEFAULT *errors.EDAMNotFoundException

func (p *UserStoreGetPublicUserInfoResult) GetNotFoundException() *errors.EDAMNotFoundException {
	if !p.IsSetNotFoundException() {
		return UserStoreGetPublicUserInfoResult_NotFoundException_DEFAULT
	}
	return p.NotFoundException
}

var UserStoreGetPublicUserInfoResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreGetPublicUserInfoResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreGetPublicUserInfoResult_SystemException_DEFAULT
	}
	return p.SystemException
}

var UserStoreGetPublicUserInfoResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetPublicUserInfoResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetPublicUserInfoResult_UserException_DEFAULT
	}
	return p.UserException
}
func (p *UserStoreGetPublicUserInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetNotFoundException() bool {
	return p.NotFoundException != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreGetPublicUserInfoResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetPublicUserInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &PublicUserInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField1(iprot thrift.TProtocol) error {
	p.NotFoundException = &errors.EDAMNotFoundException{}
	if err := p.NotFoundException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) readField3(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getPublicUserInfo_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetPublicUserInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetNotFoundException() {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:notFoundException: ", p), err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:notFoundException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetPublicUserInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetPublicUserInfoResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreGetUserUrlsArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreGetUserUrlsArgs() *UserStoreGetUserUrlsArgs {
	return &UserStoreGetUserUrlsArgs{}
}

func (p *UserStoreGetUserUrlsArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreGetUserUrlsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetUserUrlsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreGetUserUrlsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUserUrls_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetUserUrlsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreGetUserUrlsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetUserUrlsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreGetUserUrlsResult struct {
	Success         *UserUrls                   `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreGetUserUrlsResult() *UserStoreGetUserUrlsResult {
	return &UserStoreGetUserUrlsResult{}
}

var UserStoreGetUserUrlsResult_Success_DEFAULT *UserUrls

func (p *UserStoreGetUserUrlsResult) GetSuccess() *UserUrls {
	if !p.IsSetSuccess() {
		return UserStoreGetUserUrlsResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreGetUserUrlsResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetUserUrlsResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetUserUrlsResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreGetUserUrlsResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreGetUserUrlsResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreGetUserUrlsResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreGetUserUrlsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetUserUrlsResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetUserUrlsResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreGetUserUrlsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetUserUrlsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &UserUrls{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetUserUrlsResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetUserUrlsResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreGetUserUrlsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getUserUrls_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetUserUrlsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserUrlsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserUrlsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetUserUrlsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetUserUrlsResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - EmailAddress
type UserStoreInviteToBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
	EmailAddress        string `thrift:"emailAddress,2" json:"emailAddress"`
}

func NewUserStoreInviteToBusinessArgs() *UserStoreInviteToBusinessArgs {
	return &UserStoreInviteToBusinessArgs{}
}

func (p *UserStoreInviteToBusinessArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}

func (p *UserStoreInviteToBusinessArgs) GetEmailAddress() string {
	return p.EmailAddress
}
func (p *UserStoreInviteToBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreInviteToBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreInviteToBusinessArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EmailAddress = v
	}
	return nil
}

func (p *UserStoreInviteToBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("inviteToBusiness_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreInviteToBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreInviteToBusinessArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("emailAddress", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:emailAddress: ", p), err)
	}
	if err := oprot.WriteString(string(p.EmailAddress)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.emailAddress (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:emailAddress: ", p), err)
	}
	return err
}

func (p *UserStoreInviteToBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreInviteToBusinessArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
type UserStoreInviteToBusinessResult struct {
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreInviteToBusinessResult() *UserStoreInviteToBusinessResult {
	return &UserStoreInviteToBusinessResult{}
}

var UserStoreInviteToBusinessResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreInviteToBusinessResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreInviteToBusinessResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreInviteToBusinessResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreInviteToBusinessResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreInviteToBusinessResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreInviteToBusinessResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreInviteToBusinessResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreInviteToBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreInviteToBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreInviteToBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreInviteToBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("inviteToBusiness_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreInviteToBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreInviteToBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreInviteToBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreInviteToBusinessResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - EmailAddress
type UserStoreRemoveFromBusinessArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
	EmailAddress        string `thrift:"emailAddress,2" json:"emailAddress"`
}

func NewUserStoreRemoveFromBusinessArgs() *UserStoreRemoveFromBusinessArgs {
	return &UserStoreRemoveFromBusinessArgs{}
}

func (p *UserStoreRemoveFromBusinessArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}

func (p *UserStoreRemoveFromBusinessArgs) GetEmailAddress() string {
	return p.EmailAddress
}
func (p *UserStoreRemoveFromBusinessArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.EmailAddress = v
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("removeFromBusiness_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreRemoveFromBusinessArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("emailAddress", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:emailAddress: ", p), err)
	}
	if err := oprot.WriteString(string(p.EmailAddress)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.emailAddress (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:emailAddress: ", p), err)
	}
	return err
}

func (p *UserStoreRemoveFromBusinessArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRemoveFromBusinessArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
//  - NotFoundException
type UserStoreRemoveFromBusinessResult struct {
	UserException     *errors.EDAMUserException     `thrift:"userException,1" json:"userException,omitempty"`
	SystemException   *errors.EDAMSystemException   `thrift:"systemException,2" json:"systemException,omitempty"`
	NotFoundException *errors.EDAMNotFoundException `thrift:"notFoundException,3" json:"notFoundException,omitempty"`
}

func NewUserStoreRemoveFromBusinessResult() *UserStoreRemoveFromBusinessResult {
	return &UserStoreRemoveFromBusinessResult{}
}

var UserStoreRemoveFromBusinessResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreRemoveFromBusinessResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreRemoveFromBusinessResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreRemoveFromBusinessResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreRemoveFromBusinessResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreRemoveFromBusinessResult_SystemException_DEFAULT
	}
	return p.SystemException
}

var UserStoreRemoveFromBusinessResult_NotFoundException_DEFAULT *errors.EDAMNotFoundException

func (p *UserStoreRemoveFromBusinessResult) GetNotFoundException() *errors.EDAMNotFoundException {
	if !p.IsSetNotFoundException() {
		return UserStoreRemoveFromBusinessResult_NotFoundException_DEFAULT
	}
	return p.NotFoundException
}
func (p *UserStoreRemoveFromBusinessResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreRemoveFromBusinessResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreRemoveFromBusinessResult) IsSetNotFoundException() bool {
	return p.NotFoundException != nil
}

func (p *UserStoreRemoveFromBusinessResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessResult) readField3(iprot thrift.TProtocol) error {
	p.NotFoundException = &errors.EDAMNotFoundException{}
	if err := p.NotFoundException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("removeFromBusiness_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreRemoveFromBusinessResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRemoveFromBusinessResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRemoveFromBusinessResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetNotFoundException() {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreRemoveFromBusinessResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreRemoveFromBusinessResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - OldEmailAddress
//  - NewEmailAddress_
type UserStoreUpdateBusinessUserIdentifierArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
	OldEmailAddress     string `thrift:"oldEmailAddress,2" json:"oldEmailAddress"`
	NewEmailAddress_    string `thrift:"newEmailAddress,3" json:"newEmailAddress"`
}

func NewUserStoreUpdateBusinessUserIdentifierArgs() *UserStoreUpdateBusinessUserIdentifierArgs {
	return &UserStoreUpdateBusinessUserIdentifierArgs{}
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) GetOldEmailAddress() string {
	return p.OldEmailAddress
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) GetNewEmailAddress_() string {
	return p.NewEmailAddress_
}
func (p *UserStoreUpdateBusinessUserIdentifierArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.OldEmailAddress = v
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) readField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 3: ", err)
	} else {
		p.NewEmailAddress_ = v
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateBusinessUserIdentifier_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("oldEmailAddress", thrift.STRING, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:oldEmailAddress: ", p), err)
	}
	if err := oprot.WriteString(string(p.OldEmailAddress)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.oldEmailAddress (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:oldEmailAddress: ", p), err)
	}
	return err
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("newEmailAddress", thrift.STRING, 3); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:newEmailAddress: ", p), err)
	}
	if err := oprot.WriteString(string(p.NewEmailAddress_)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.newEmailAddress (3) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 3:newEmailAddress: ", p), err)
	}
	return err
}

func (p *UserStoreUpdateBusinessUserIdentifierArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreUpdateBusinessUserIdentifierArgs(%+v)", *p)
}

// Attributes:
//  - UserException
//  - SystemException
//  - NotFoundException
type UserStoreUpdateBusinessUserIdentifierResult struct {
	UserException     *errors.EDAMUserException     `thrift:"userException,1" json:"userException,omitempty"`
	SystemException   *errors.EDAMSystemException   `thrift:"systemException,2" json:"systemException,omitempty"`
	NotFoundException *errors.EDAMNotFoundException `thrift:"notFoundException,3" json:"notFoundException,omitempty"`
}

func NewUserStoreUpdateBusinessUserIdentifierResult() *UserStoreUpdateBusinessUserIdentifierResult {
	return &UserStoreUpdateBusinessUserIdentifierResult{}
}

var UserStoreUpdateBusinessUserIdentifierResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreUpdateBusinessUserIdentifierResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreUpdateBusinessUserIdentifierResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreUpdateBusinessUserIdentifierResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreUpdateBusinessUserIdentifierResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreUpdateBusinessUserIdentifierResult_SystemException_DEFAULT
	}
	return p.SystemException
}

var UserStoreUpdateBusinessUserIdentifierResult_NotFoundException_DEFAULT *errors.EDAMNotFoundException

func (p *UserStoreUpdateBusinessUserIdentifierResult) GetNotFoundException() *errors.EDAMNotFoundException {
	if !p.IsSetNotFoundException() {
		return UserStoreUpdateBusinessUserIdentifierResult_NotFoundException_DEFAULT
	}
	return p.NotFoundException
}
func (p *UserStoreUpdateBusinessUserIdentifierResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) IsSetNotFoundException() bool {
	return p.NotFoundException != nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.readField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) readField3(iprot thrift.TProtocol) error {
	p.NotFoundException = &errors.EDAMNotFoundException{}
	if err := p.NotFoundException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.NotFoundException), err)
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("updateBusinessUserIdentifier_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetNotFoundException() {
		if err := oprot.WriteFieldBegin("notFoundException", thrift.STRUCT, 3); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 3:notFoundException: ", p), err)
		}
		if err := p.NotFoundException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.NotFoundException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 3:notFoundException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreUpdateBusinessUserIdentifierResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreUpdateBusinessUserIdentifierResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
type UserStoreListBusinessUsersArgs struct {
	AuthenticationToken string `thrift:"authenticationToken,1" json:"authenticationToken"`
}

func NewUserStoreListBusinessUsersArgs() *UserStoreListBusinessUsersArgs {
	return &UserStoreListBusinessUsersArgs{}
}

func (p *UserStoreListBusinessUsersArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}
func (p *UserStoreListBusinessUsersArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreListBusinessUsersArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreListBusinessUsersArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessUsers_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreListBusinessUsersArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreListBusinessUsersArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreListBusinessUsersArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreListBusinessUsersResult struct {
	Success         []*types.UserProfile        `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreListBusinessUsersResult() *UserStoreListBusinessUsersResult {
	return &UserStoreListBusinessUsersResult{}
}

var UserStoreListBusinessUsersResult_Success_DEFAULT []*types.UserProfile

func (p *UserStoreListBusinessUsersResult) GetSuccess() []*types.UserProfile {
	return p.Success
}

var UserStoreListBusinessUsersResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreListBusinessUsersResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreListBusinessUsersResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreListBusinessUsersResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreListBusinessUsersResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreListBusinessUsersResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreListBusinessUsersResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreListBusinessUsersResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreListBusinessUsersResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreListBusinessUsersResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreListBusinessUsersResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*types.UserProfile, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem33 := &types.UserProfile{}
		if err := _elem33.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem33), err)
		}
		p.Success = append(p.Success, _elem33)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *UserStoreListBusinessUsersResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreListBusinessUsersResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreListBusinessUsersResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessUsers_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreListBusinessUsersResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreListBusinessUsersResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreListBusinessUsersResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreListBusinessUsersResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreListBusinessUsersResult(%+v)", *p)
}

// Attributes:
//  - AuthenticationToken
//  - IncludeRequestedInvitations
type UserStoreListBusinessInvitationsArgs struct {
	AuthenticationToken         string `thrift:"authenticationToken,1" json:"authenticationToken"`
	IncludeRequestedInvitations bool   `thrift:"includeRequestedInvitations,2" json:"includeRequestedInvitations"`
}

func NewUserStoreListBusinessInvitationsArgs() *UserStoreListBusinessInvitationsArgs {
	return &UserStoreListBusinessInvitationsArgs{}
}

func (p *UserStoreListBusinessInvitationsArgs) GetAuthenticationToken() string {
	return p.AuthenticationToken
}

func (p *UserStoreListBusinessInvitationsArgs) GetIncludeRequestedInvitations() bool {
	return p.IncludeRequestedInvitations
}
func (p *UserStoreListBusinessInvitationsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		p.AuthenticationToken = v
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsArgs) readField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return thrift.PrependError("error reading field 2: ", err)
	} else {
		p.IncludeRequestedInvitations = v
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessInvitations_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("authenticationToken", thrift.STRING, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:authenticationToken: ", p), err)
	}
	if err := oprot.WriteString(string(p.AuthenticationToken)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.authenticationToken (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:authenticationToken: ", p), err)
	}
	return err
}

func (p *UserStoreListBusinessInvitationsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("includeRequestedInvitations", thrift.BOOL, 2); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:includeRequestedInvitations: ", p), err)
	}
	if err := oprot.WriteBool(bool(p.IncludeRequestedInvitations)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.includeRequestedInvitations (2) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 2:includeRequestedInvitations: ", p), err)
	}
	return err
}

func (p *UserStoreListBusinessInvitationsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreListBusinessInvitationsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
//  - SystemException
type UserStoreListBusinessInvitationsResult struct {
	Success         []*types.BusinessInvitation `thrift:"success,0" json:"success,omitempty"`
	UserException   *errors.EDAMUserException   `thrift:"userException,1" json:"userException,omitempty"`
	SystemException *errors.EDAMSystemException `thrift:"systemException,2" json:"systemException,omitempty"`
}

func NewUserStoreListBusinessInvitationsResult() *UserStoreListBusinessInvitationsResult {
	return &UserStoreListBusinessInvitationsResult{}
}

var UserStoreListBusinessInvitationsResult_Success_DEFAULT []*types.BusinessInvitation

func (p *UserStoreListBusinessInvitationsResult) GetSuccess() []*types.BusinessInvitation {
	return p.Success
}

var UserStoreListBusinessInvitationsResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreListBusinessInvitationsResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreListBusinessInvitationsResult_UserException_DEFAULT
	}
	return p.UserException
}

var UserStoreListBusinessInvitationsResult_SystemException_DEFAULT *errors.EDAMSystemException

func (p *UserStoreListBusinessInvitationsResult) GetSystemException() *errors.EDAMSystemException {
	if !p.IsSetSystemException() {
		return UserStoreListBusinessInvitationsResult_SystemException_DEFAULT
	}
	return p.SystemException
}
func (p *UserStoreListBusinessInvitationsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreListBusinessInvitationsResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreListBusinessInvitationsResult) IsSetSystemException() bool {
	return p.SystemException != nil
}

func (p *UserStoreListBusinessInvitationsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.readField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsResult) readField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return thrift.PrependError("error reading list begin: ", err)
	}
	tSlice := make([]*types.BusinessInvitation, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem34 := &types.BusinessInvitation{}
		if err := _elem34.Read(iprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", _elem34), err)
		}
		p.Success = append(p.Success, _elem34)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return thrift.PrependError("error reading list end: ", err)
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsResult) readField2(iprot thrift.TProtocol) error {
	p.SystemException = &errors.EDAMSystemException{}
	if err := p.SystemException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.SystemException), err)
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("listBusinessInvitations_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreListBusinessInvitationsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return thrift.PrependError("error writing list begin: ", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", v), err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return thrift.PrependError("error writing list end: ", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreListBusinessInvitationsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreListBusinessInvitationsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetSystemException() {
		if err := oprot.WriteFieldBegin("systemException", thrift.STRUCT, 2); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 2:systemException: ", p), err)
		}
		if err := p.SystemException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.SystemException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 2:systemException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreListBusinessInvitationsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreListBusinessInvitationsResult(%+v)", *p)
}

// Attributes:
//  - ServiceLevel
type UserStoreGetAccountLimitsArgs struct {
	ServiceLevel types.ServiceLevel `thrift:"serviceLevel,1" json:"serviceLevel"`
}

func NewUserStoreGetAccountLimitsArgs() *UserStoreGetAccountLimitsArgs {
	return &UserStoreGetAccountLimitsArgs{}
}

func (p *UserStoreGetAccountLimitsArgs) GetServiceLevel() types.ServiceLevel {
	return p.ServiceLevel
}
func (p *UserStoreGetAccountLimitsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetAccountLimitsArgs) readField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return thrift.PrependError("error reading field 1: ", err)
	} else {
		temp := types.ServiceLevel(v)
		p.ServiceLevel = temp
	}
	return nil
}

func (p *UserStoreGetAccountLimitsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAccountLimits_args"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetAccountLimitsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("serviceLevel", thrift.I32, 1); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:serviceLevel: ", p), err)
	}
	if err := oprot.WriteI32(int32(p.ServiceLevel)); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T.serviceLevel (1) field write error: ", p), err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write field end error 1:serviceLevel: ", p), err)
	}
	return err
}

func (p *UserStoreGetAccountLimitsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetAccountLimitsArgs(%+v)", *p)
}

// Attributes:
//  - Success
//  - UserException
type UserStoreGetAccountLimitsResult struct {
	Success       *types.AccountLimits      `thrift:"success,0" json:"success,omitempty"`
	UserException *errors.EDAMUserException `thrift:"userException,1" json:"userException,omitempty"`
}

func NewUserStoreGetAccountLimitsResult() *UserStoreGetAccountLimitsResult {
	return &UserStoreGetAccountLimitsResult{}
}

var UserStoreGetAccountLimitsResult_Success_DEFAULT *types.AccountLimits

func (p *UserStoreGetAccountLimitsResult) GetSuccess() *types.AccountLimits {
	if !p.IsSetSuccess() {
		return UserStoreGetAccountLimitsResult_Success_DEFAULT
	}
	return p.Success
}

var UserStoreGetAccountLimitsResult_UserException_DEFAULT *errors.EDAMUserException

func (p *UserStoreGetAccountLimitsResult) GetUserException() *errors.EDAMUserException {
	if !p.IsSetUserException() {
		return UserStoreGetAccountLimitsResult_UserException_DEFAULT
	}
	return p.UserException
}
func (p *UserStoreGetAccountLimitsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *UserStoreGetAccountLimitsResult) IsSetUserException() bool {
	return p.UserException != nil
}

func (p *UserStoreGetAccountLimitsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read error: ", p), err)
	}

	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return thrift.PrependError(fmt.Sprintf("%T field %d read error: ", p, fieldId), err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.readField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.readField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T read struct end error: ", p), err)
	}
	return nil
}

func (p *UserStoreGetAccountLimitsResult) readField0(iprot thrift.TProtocol) error {
	p.Success = &types.AccountLimits{}
	if err := p.Success.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.Success), err)
	}
	return nil
}

func (p *UserStoreGetAccountLimitsResult) readField1(iprot thrift.TProtocol) error {
	p.UserException = &errors.EDAMUserException{}
	if err := p.UserException.Read(iprot); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T error reading struct: ", p.UserException), err)
	}
	return nil
}

func (p *UserStoreGetAccountLimitsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getAccountLimits_result"); err != nil {
		return thrift.PrependError(fmt.Sprintf("%T write struct begin error: ", p), err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return thrift.PrependError("write field stop error: ", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return thrift.PrependError("write struct stop error: ", err)
	}
	return nil
}

func (p *UserStoreGetAccountLimitsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 0:success: ", p), err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.Success), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 0:success: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetAccountLimitsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetUserException() {
		if err := oprot.WriteFieldBegin("userException", thrift.STRUCT, 1); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field begin error 1:userException: ", p), err)
		}
		if err := p.UserException.Write(oprot); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T error writing struct: ", p.UserException), err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return thrift.PrependError(fmt.Sprintf("%T write field end error 1:userException: ", p), err)
		}
	}
	return err
}

func (p *UserStoreGetAccountLimitsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("UserStoreGetAccountLimitsResult(%+v)", *p)
}
